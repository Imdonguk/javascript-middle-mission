<h1>학습키워드<h1>
##1. 비트연산자 보수이해하기
	- 10을 2진표현으로 변경하려면 어떤 순서로 계산해야 하는지 설명하기.

	* 비트연산자 
		(1) AND연산자 : 한쌍의 비트에 AND가 수행되면, 양쪽 비트가 모두 1이면 1을 반환합니다. 
		(2) OR연산자 : 한쌍의 비트에 OR가 수행되면, 양쪽 비트중 한쪽이 1이면 1을 반환합니다.
		(3) XOR연산자(^) : 한쌍의 비트에 XOR가 수행되면, 두 비트가 다른경우에 1을 반환합니다.
		(4) NOT연산자(~) : 한개의 비트에 NOT연산자가 수행되면 모든 비트가 반전된다.
		(5) 왼쪽SHIFT연산자 : 비트가 왼쪽으로 이동합니다. 오른쪽에서 제로 비트가 채워지고 가장 왼쪽비트가 누락됩니다. 
		(6) 오른쪽SHIFT연산자 : 비트가 오른쪽으로 이동합니다. 왼쪽에서 제로 비트가 채워지고 가장 오른쪽비트가 누락됩니다.
	* 보수 
		(1) 1의 보수 : 모든 비트를 반전시킨다. 0이면 1로 1이면 0으로 반전시킨다. 연산자는 NOT(~)를 사용하면된다.
		(2) 2의 보수 : 1의 보수에서 1을 더한다. 음수를 표현할 때 사용한다. 
			ex) 0000 0000 0000 0000 0000 0000 0000 0101 > 5
				1111 1111 1111 1111 1111 1111 1111 1011 > -5

	* 10을 2진표현으로 변경
				 몫		나머지
		10 / 2   5		 0
		5  / 2   2 		 1
		2  / 2   1 		 0
		1  / 2   0       1
		밑에서부터 1010이 10을 2진수로 변경한 것이다.

	*느낀점
		비트연산자는 확실히 잘쓰면 도움이 많이 될꺼라는 생각이 들었다. 
		알고리즘을 하다가 Tim이 XOR연산자를 사용해서 엄청 쉽게 푸는 것을 보고
		잘쓰면 정말 좋겠다라는 생각이 들었다.
		그리고 보수는 음수를 표현하기 위해 사용하는 정도로만 알고있다.

##2. hoisting 에 대해서 설명하기
	* hoisting
		- 모든 변수는 호이스트됩니다. 호이스트는 변수의 정의가 그 범위에 따라 선언과 할당으로 분리되는 것을 의미합니다. 함수내에서 정의하였을 경우 선언은 함수의 최상위로 함수 바깥에서 정의되었을 경우엔 전역공간 최상위로 변경됩니다.
		- 디버깅할 때 변수를 보면 아직 선언을 하지 않았으나 변수가 undefined로 선언이 된 것을 확인할 수 있다.
		할당이 된 후에야 값을 할당받는다.
		- 함수의 경우 함수표현식과 함수선언식이 있는데 함수 선언식은 코드를 구현한 위치와 관계없이 호이스팅 되어 브라우저가 스크립트를 해석할 때 맨 위로 끌어 올려진다.
		ex)
		function declarations(){
			console.log("하이");
		}
		var expressions = function(){
			console.log("웅 코드스쿼드 하이");
		}
		디버깅을 해서 보면 Global Scope에 declarations : f() 이렇게 나오고 expressions : undefined로 나온다.
	*느낀점
		변수의 범위에 대해서 생각하게 다시한번 생각하게 됐다. 또 변수의 선언과 할당이 동시에 이루어 지는게 아니라는 것을 알게 되었고,
		함수선언문은 선언동시에 호이스팅되어서 브라우저가 자바스크립트를 해석할 때 맨위로 끌어 올려서 가장 빨리 해석한 다는 것을 알았다.
		솔직히 많이 헷갈리는 부분이라서 나의 지식으로 만들기위해서는 코드를 짜면서 자주 생각하는게 좋은 것 같다. 
		현재는 함수표현식과 함수선언식을 생각하면서 사용하는 것이 좋다는 생각이 든다.

##3. !! 은 무엇을 의미하는가? 어떻게 활용할 수 있을까?
	자바스크립트에서 type이 다르다고 하더라도 boolean값이 존재한다.
	!는 부정을 뜻한다.
	!true이면 false이고 반대로 !false이면 true이다.
	아까 말했듯이 모든 값들은 boolean값을 가지고 있는데
	!! 부정을 두번하면 모든 type들의 boolean값을 얻을 수 있다.
	ex) let a = "crong";
	console.log(!a) //false;
	console.log(!!a) //true;
	a의 boolean값을 구할 수 있다.

	*느낀점
	오! 이런방법도 있구나라고 생각했다. 처음에는 부정의부정이면 똑같은 값이잖아 이런 생각이 들었는데
	자세히 들여다보니깐 boolean값을 구할 수 있겠구나 생각했다. 앞으로 쓸일이 많을 것 같다.

##4. 3개이상의 switch 문을 어떻게 3항연산자로 대체할 수 있을까? 코드로 예시를 들라.
	- 예시)
	let a = 5;
	  a === 1 ? console.log(a) : a === 2 ? console.log(a)
	: a === 3 ? console.log(a) : a === 4 ? console.log(a)
	: a === 5 ? console.log(a) : console.log("머야이거");     //결과값 5
	*느낀점
		알고리즘 하면서 tim이나 R 등 다른분들이 3항연산자를 사용하는 것을 보고 처음에는 머야이거 약간 이런생각이 들었었는데
		알고 보니깐 저렇게도 쓰는구나라고 느꼈고 간단한 if문이나 switch문 같은 경우에는 3항연산자를 사용해 간략하게 표현하는것도 좋은것 같다.

##5. ==와 ===의 차이는 정확히 무엇인가?
	254 == '254'                // return true
	true == 1                   // return true
	undefined == null           // return true
	'abc' == new String('abc')  // return true
	- ==을 사용하면 연산이 되기 전에 피연산자들을 먼저 비교할 수 있는 형태로 변환시킨다!!

	254 === '254'               // return false
	true === 1                  // return false
	undefined === null          // return false
	'abc' === new String('abc') // return false
	- ===은 ==과 다르게 형변환을 하지 않고 연산한다.
	*느낀점
		코딩을 하면서 ==이 비교할 수 있게 형변환을 시켜준다고 해서 이번에 if([] == 0)이런식으로 한번 써먹어봤다.
		좋은건지 안좋은건지는 모르지만 공부한김에 한번 써먹은게 그냥 좋았다.

##6. const value = a || b; 코드의 의미는 무엇인가?
	*const value = a||b;
		- 이것은 a가 참이면 b의 값을 보지 않고 바로 a를 value값에 넣고 a의 값이 없으면 b를 넣는다.
	*느낀점
		이것은 크롱이 강의를 할 때 한번 씩 본 것 같다. 
		function crong(a){
			this.a = a || "코드스쿼드"
		}
		이런식으로 했을 때 a에 값을 넣어주지않으면 "코드스쿼드"라는 값이 변수에 할당된다.
		앞으로 사용할 때 값에 아무것도 안들어갔을 때 디폴트값으로 정해줘서 사용을 하면 좋겠다는 생각이 들었다.

##7. eval 은 무엇인가?
	* eval()함수의 인자는 문자열이다. 
	문자열 안에 있는 코드를 문자열로 반환하는게 아니라 문자열 안에 있는 수행식을 반환한다.
	eval을 사용하면 String형태의 javascript소스를 실행시킬 수 있다.
	ex) let x = 5; let y = 10; let z = "15";
	console.log(eval("x+y"));   //15를 반환
	console.log(eval(z));		//15를 반환
	let str = "if(x === 5) console.log(\"x는 \" + x);"
	eval(str);	//x는 5를 출력!
	* 느낀점
	eval()이라는 함수를 처음 알았는데 이런 것도 있구나라고 처음에는 느꼈다. 그런데 찾아보고 하니깐 이게 자바스크립트 코드 최적화 관련 글에서는 eval함수 사용 자제가 많이 된다. 하지만 프레임워크 구현 등 보다 높은 수준에서 자바스크립트를 사용하는 상황에서는 eval함수의 적절한 활용이 필수적이라고 한다. 

##8. 변수값을 출력할때 null, undefined, is not defined으로 출력되는 차이점은 무엇인가?
	(1) undefined
		- undefined는 선언은 되었는데 값이 할당이 안되면 undefined라는 값이 할당된다.
	(2) is not defined
		- is not defined는 할당이 되기전에 선언조차 되어있지 않으면 is not defined라는 오류메시지가 뜬다.
	(3) null
		- null은 null이라는 값을 할당 받은 것을 뜻합니다. 
		undefined = "crong"; // "crong"
		nuill = "crong" //Reference Error
		undefined는 아무값도 할당되지않은상태라 값을 할당할 수 있지만 null은 아니다.
	*느낀점
		이번에 tim이 null과 undefined의 설명을 해줬는데 google에 쳐서 사진을 보니깐
		화장실 두루마리휴지에 화장지를 다써서 휴지가 없는게 null값이고
		두루마리휴지 자체가 없으면 undefined라고 나와있었다.
		값이 있는데 비어있으면 null이고 값이 아예 할당이 안됐으면 undefined라고 생각한다.
		앞으로 코딩을 하면서 어떻게 써볼지는 고민을 해보겠다.
##9. add(10)(2) //12 가 되도록 구현해보기.
	- 구현해보기!
	let sum = function(firstNumber){

		return function (secondNumber){
			return firstNumber + secondNumber;
		}
	}
	sum(10)(2) //12;
	*느낀점
		내부함수는 외부함수에 있는 변수들을 참조할 수 있고 외부변수가 호출되어 콜스택에서 사라진다고해도 참고하고 있는 변수는 내부함수에서 계속 참조한다.
		이것을 공부하면서 클로저에 대해서 다시한번 공부하게 되고 변수의 범위에 대해서 다시한번 공부한 것 같다. 매우 중요하다고 생각이 된다.

##10. 함수의 인자갯수와 파라미터가 일치하지 않으면 어떤일이 생기는가 설명하기
	* javascript에서는 함수안에 파라미터변수의 갯수와 함수를 호출할 때 인자갯수가 다르더라도 에러가 생기지않는다.
	ex) (1) 파라미터값이 3개이고 호출할 때 인자의 개수가 2개일때
	function crong(a,b,c) console.log(a,b,c);
	crong(3,5);		//결과값이 3,5,undefined 이 출력된다.
	(2) 파라미터값이 3개이고 호출할 때 인자의 개수가 4개일때
	crong(3,5,7,9)	//결과값은 3,5,7이 출력된다.
	함수안에서 파라미터안에 있는 값들은 arguments[0],arguments[1] 이렇게 활용할 수 있다.
	4번째 인자값으로 들어온 값도 함수안에서 arguments[3]를 정의해서 사용할 수 있다.

	*느낀점
	나는 javascript를 하면서 정말 좋다고 생각한다. 다른 언어에서는 오류가 나는 걸로 알고 있는데 자바스크립트는 그렇지가 않아서 좋다
	또 이것 이외의 인자로 함수를 받을 수도 있고 ...args 이렇게 사용해서 파라미터의 값들을 배열로 받을 수도 있다. arguments는 진짜배열이 아니지만
	...args이렇게 해서 파라미터를 배열로 받으면 진짜 배열이 된다!
##11. 함수의 반환값이 없을때 어떻게 되는가?
	- undefined 값이 반환된다.
	ex) function test(){}
		typeof test(); //undefined
	*느낀점
		함수는 디폴트값이 undefined구나 라고 느낀다.

##12. 익명함수는 무엇인가?
	- 일반적인 함수 처리 법은 함수를 만들고 함수이름을 설정하고 파라미터값을 넣어서 값을 출력합니다. 재사용이 용이합니다. 하지만 굳이 재사용을 할 필요가 없다면 이름같은거 붙이지 말고 변수에 바로 함수를 달아버립니다. 그러면 함수에는 굳이 이름이 필요없기 때문에 익명함수라고 합니다. 
	ex) 
	let example = function (a,b){return a+b;};

	*느낀점
		배열메소드 forEach, map, filter를 쓸 때 익명함수를 많이 써봤다. 그런데 생각을 함수를 변수처럼 생각하는 것도 좋은 방법인 거같다. 
		예를 들어)
		let x = 5;
		let y = 10;
		let sum = (function (a,b){ return a+b;})(x,y);
		이렇게 하면 sum안에 있는 함수를 값으로 바로 받을 수 있다. 이렇게 함수의 행동을 변수에 담아서
		메인 함수에서 출력하게 하는 방법도 좋은 방법인 거 같다고 느낀다!
